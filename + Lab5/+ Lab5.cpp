#include<locale.h> // заголовочгый файл для функции setlocale()
#include<iomanip> // заголовочный файл для cout, « и много чего еще
#include<bitset>
#include<iostream>

/*
Динамическая память(C++)
Определения и синтаксис
Класс - шаблонное описание, по которому создаются объекты.В некотором роде аналогичен типу данных - является всего лишь описанием, по которому могут быть созданы многочисленные экземпляры.
class car // игровое транспортное средство
{
    double max_speed = 120; // свойство, скорость, проинициализирована
    double fuel_consumption; // свойство, потребление топлива
    double current_speed; // свойство, скорость
    char regnumber[6] = { 0 }; // свойство, госномер
    unsigned char capacity; // свойство, число пасажиров
    accelerate(double v); // метод, увеличить скорость
    get_coordinate(/*... *//*); // метод, получить текущее положение
    /*
    change_color(/*...*//*); // метод, сменить текстуру
}
/*
Объект - экземпляр класса.В каком - то роде аналогичен переменной : можно создать переменную M типа N, и объект K класса L.
// где-то в коде:
car car_object1; // объект в стековой памяти (локальный)
car* car_object2; // указатель на объект в динамической памяти
car_object2 = new car; // создание самого объекта в динамической памяти
Методы - функции в составе класса(объявленные внутри класса).
Свойства - переменные в составе класса(объявленные внутри класса).
Чтобы воспользоваться свойствами и методами конструктора, используются операторы доступа “.” если объект локальный и “->” если объект представлен указателем :
// где-то в коде:
car_object1.max_speed = 150; // для локального объекта
car_object1.accelerate(150); // для локального объекта

car_object2->max_speed = 150; // для объекта, представленного указателем
car_object2->accelerate(150); // для объекта, представленного указателем

Чтобы изнутри конструктора сослаться на объект, который его представляет, используется указатель this.
Конструктор - метод класса, автоматически подставляемый компилятором в код без участия программиста в момент создания объекта класса.Конструктор необходим в случае
если при создании объекта нужно выполнять действия по инициализации, установлению сетевого соединения, открытию файлов, выделению динамической памяти и т.д.
если при создании объекта нужно скопировать его свойства на основе другого объекта.
Конструктор всегда по правилам C++ имеет то же имя, что и класс, и не возвращает параметров :
class car // игровое транспортное средство
{
    car() {} // конструктор по умолчанию
    car(car another_car) // копирующий конструктор
    {
        this->max_speed = another_car.max_speed;
        this->fuel_consumption = another_car.fuel_consumption;
        this->current_speed = another_car.current_speed;
        this->capacity = another_car.capacity;
    }
}
Если при уничтожении объекта нужно освобождать некоторые общие ресурсы и выполнять другие обязательные действия, объявляется метод - деструктор.Деструктор подставляется компилятором автоматически в код, когда прекращается срок жизни объекта(в конце функции, где был объявлен объект, либо в конце работы приложения).Деструктор не получает и возвращает параметров.Имя деструктора всегда равно имени класса с тильдой в начале :
class car // игровое транспортное средство
{
    ~car() // деструктор
    {
        save_to_file();
        close_file();
        delete[] block_of_memory;
        connection.close();
    }
}
Методы + свойства = поля класса.
Инкапсуляция, наследование и полиморфизм - три основные идеи(парадигмы) ООП.
Инкапсуляция - фактически, объединение данных и методов, объединённых общим смыслом, в одну конструкцию(класс), а также защита данных и механизмов конструкции от стороннего вмешательства.
Наследование - создание дочернего класса от некоего родительского и заимствование в дочернем свойств и методов родительского.Позволяет быстро обновлять / изменять кодовую базу : изменения в родительском классе автоматически применяются ко всем дочерним.Один класс можно наследовать от нескольких родительских.

Полиморфизм - простыми словами : экземпляры одного класса ведут себя по - разному.
Для ограничения доступа в стороннем коде к полям класса применяются спецификаторы доступа public, protected и private (если не применять ни один из спецификаторов, по умолчанию работает private) :
    class car // игровое транспортное средство
{
private: // всё, что ниже до следующего спецификатора, будет private
    double max_speed = 120; // свойство, недоступное извне
    double fuel_consumption; // свойство, недоступное извне
    double current_speed; // свойство, недоступное извне
    char regnumber[6] = { 0 }; // свойство, недоступное извне
    unsigned char capacity; // свойство, недоступное извне
    get_coordinate(/*... *//*); // метод, недоступный извне
/*
public:
    car(/*???*//*); // должен быть в public
    /*
    change_color(/*...*//*); // метод, доступный извне
    /*
    accelerate(double v); // метод, доступный извне
}
/*
После таких изменений в классе изменится поведение объекта :
// где-то в коде
car_object1.max_speed = 150; // !!!ВЫЗОВЕТ ОШИБКУ КОМПИЛЯЦИИ
car_object1.change_color(“cherry”);
Пример кода модуля с классом :
#include<iostream>
#include<string>
class car // игровое транспортное средство
{
private: // всё, что ниже до следующего спецификатора, будет private
    double max_speed = 120; // свойство, недоступное извне
    double fuel_consumption; // свойство, недоступное извне
    double current_speed; // свойство, недоступное извне
    char regnumber[6] = { 0 }; // свойство, недоступное извне
    unsigned char capacity; // свойство, недоступное извне
    double get_coordinate() { return 0.0; } // метод, недоступный извне
    std::string color = “green”;
public:
    car() {}
    void change_color(std::string pColor); // метод, определённый СНАРУЖИ
    bool accelerate(double v) // метод, определённый ВНУТРИ класса
    {
        if (v <= this->max_speed)
        {
            this->current_speed = v;
            return true;
        }
        else
            return false;
    }
};
void car::change_color(std::string pColor) // метод, определённый СНАРУЖИ
{
    this->color = pColor;
}

int main(void)
{
    // настройка локализации и кодировки

    car car_object1; // объект в стековой памяти (локальный)
    car* car_object2; // указатель на объект в динамической памяти
    car_object2 = new car; // создание самого объекта в динамической памяти

    car_object1.max_speed = 150; // !!!ВЫЗОВЕТ ОШИБКУ КОМПИЛЯЦИИ
    car_object1.change_color(“cherry”);
    // обращаться к остальным свойствам и вызывать прочие методы

    std::system(“pause”);
}

Применение
Пример 1. При электронной обработке документа(скажем, PDF или Word) удобно объединить в класс все функции по действиям с документом, а также все связанные с ним переменные.
class Document {
    Document(); // пустой конструктор
    Document(string filename); // конструктор, который при создании объекта также открывает файл
    insert_text(/*...*//*); // вставить фрагмент в документ
    /*
    insert_image(/*...*//*); // вставить изображение в  документ
    /*
    save(); // сохранить фрагмент в файл
    string contents; // строка, куда считывается  содержимое файла
    time_t creation_time; // время создания файла
}

*/

class Dota2 {

private:// доступ ограничен

    std::string name = " Zeus ";
    std::string name2 = " Гера ";
    double weight = 85;
    double growht = 167;
    std::string wife = "богиня Гера, покровительница брака.\n\n\n";
    std::string age = "очень много лет, известен ещё с древне греческих летописей";

public: // общий доступ

    Dota2() { std::cout << "\t\t\tНачнём нашу игровую мини-сессию\n " << this << std::endl; }// пустой конструктор
    Dota2(Dota2 const& another_GodOfWAr) {} // копирующий конструктор

    void about_zeus(std::string qua) {
        std::cout << "\t\t\t\tВызван метод about_zeus\n" << std::endl;
        std::cout << "\t\t\tИ так, Zeus - бог неба, грома и молний, именно поэтому в игре он использует свои способности ударов молний разных сил и направленностей" << std::endl;
        std::cout << "\t\t\t\tДля продолжения введите --)  Zeus\n" << std::endl;
        std::cin >> qua;
        if (qua == "Zeus") {
        }
    }
    void family(std::string qua) {
        std::cout << "\t\t\t\tВызван метод family\n" << std::endl;
        std::cout << "\t\t\tНемного информации о том, с кем связан Zeus кровно.\n\n\nЕдинственная любимая жена Зевса - покровительница брака, богиня " << name2  << " \nНе смотря на это, по приданиям у него очень много детей, от разных женщин Богинь, как это произошло - не известно, лишь истории о его гневе и семенах, попавших на землю." << std::endl;
        std::cout << "\t\t\t\tДля продолжения введите --)  Zeus\n" << std::endl;
        std::cin >> qua;
        if (qua == "Zeus") {
        }
    }
    void game_dota2(std::string game, std::string qua) {
        std::cout << "\t\t\t\tВызван метод game_dota2\n" << std::endl;
        std::cout << "\t\t\tЭто игровой опрос, будь добр, пройди его!\n\n\nКак вы относитесь к играм с заработком опыта и золота, а также убийством героев с элементами разрушения вражеских сооружений? Варианты ответа: допустимо, люблю, не играл, хотел бы поиграть, играю часто, ненавижу, не люблю" << std::endl;
        std::cin >> game;
        std::cout << "DOTA 2 - с виду сложная игра, но она быстро затягивает, тут более 100 героев различных героев, с разным основным атрибутом, очень много классных механик и игровых событий." << std::endl;
        std::cout << "\t\t\t\tДля продолжения введите --)  Zeus\n" << std::endl;
        std::cin >> qua;
        if (qua == "Zeus") {
        }
    }
 ~Dota2() { std::cout << "\t\t\tНадеюсь, тебе было интересно.\n" << this << std::endl; } // Вызов деструктора
};
void look() {
    std::cout << "\t\t\t\t\t\t\tВызвана функция look\n" << std::endl;
    std::string qua;
    std::string game;
    std::string name;
    std::string name2;
    int ball;
    Dota2 game1;
    game1.about_zeus(qua);
    game1.family(qua);
    game1.game_dota2(game, qua);
    Dota2* game2;
    game2 = new Dota2;
    game2->family(qua);
    game2->about_zeus(qua);
    game2->game_dota2(game, qua);

}


int main()
{

    setlocale(LC_ALL, "Russian");
    std::cout << "\t\t\t\t\t\t\tПодытог Lab6\n" << std::endl;
    std::string qua;
    std::string game;
    std::string name;
    std::string name2;
    int end;
    Dota2 game1;
    game1.about_zeus(qua);
    game1.family(qua);
    game1.game_dota2(game,qua);
    Dota2* game2;
    game2 = new Dota2;
    game2->family(qua);
    game2->about_zeus(qua);
    game2->game_dota2(game,qua);
    look();
    system("pause");
    return 0;
}